<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="None" />
      <link rel="shortcut icon" href="img/favicon.ico" />
    <title>hyrrokkin documentation</title>
    <link rel="stylesheet" href="css/theme.css" />
    <link rel="stylesheet" href="css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Welcome to the Hyrrokkin documentation";
        var mkdocs_page_input_path = "index.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="." class="icon icon-home"> hyrrokkin documentation
        </a>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Welcome to the Hyrrokkin documentation</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#topology">Topology</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#nodes-ports-and-links">Nodes, Ports and Links</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#packages-and-package-configurations">Packages and Package Configurations</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#an-example-package">An Example Package</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#package-schema">Package Schema</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#the-node-constructor-and-the-run-method">The node constructor, and the run method</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#persisting-node-properties">Persisting node properties</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#clients-and-updating-status">Clients and updating status</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#node-lifecycle-the-load-reset_run-run-and-close-methods">Node lifecycle - the load, reset_run, run and close methods.</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#defining-the-package-configuration">Defining the package configuration</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#creating-loading-and-running-topologies-using-the-hyrrokkin-api">Creating, loading and running topologies using the Hyrrokkin API</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#saving-and-loading-topologies">Saving and loading topologies</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#loading-saving-and-running-topologies-using-topology_runner-cli">loading, saving and running topologies using topology_runner CLI</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#using-the-hyrrokkin-expression-parser">Using the Hyrrokkin expression parser</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#parser-limitations">Parser limitations</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="configuration_api/">Configuration api</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="configuration_service_api/">Configuration service api</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="node_api/">Node api</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="node_service_api/">Node service api</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="topology_api/">Topology api</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href=".">hyrrokkin documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Welcome to the Hyrrokkin documentation</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="welcome-to-the-hyrrokkin-documentation">Welcome to the Hyrrokkin documentation</h1>
<h2 id="introduction">Introduction</h2>
<h3 id="topology">Topology</h3>
<p>Hyrrokkin is a library which manages the execution of computational graphs, which are termed topologies.  </p>
<p>Each topology consists of executable components called nodes.  </p>
<h3 id="nodes-ports-and-links">Nodes, Ports and Links</h3>
<p>Nodes are associated with a class which implements the node's behaviour, most notably the class will implement a <code>run</code> method which transforms a set of values received through that node's input ports into a set of values sent out via the node's output ports. </p>
<p>A topology will also contain links, which connect the output port of one node to the input port of another.</p>
<h3 id="packages-and-package-configurations">Packages and Package Configurations</h3>
<p>Each node in a topology is an instance of a particular node type which defines the class which implements the node's functionality, and the names and Link Types of each input and output port associated with that node.  An output port of one node can only be connected to an input port of another node can only be connected by a link if they share the same Link Type.</p>
<p>Node types and link types are bundled together into a Package containing related functionality. </p>
<p>A package may also define a package configuration which can be accessed by all nodes.    </p>
<h3 id="an-example-package">An Example Package</h3>
<p>Consider a simple example package:</p>
<ul>
<li>NumberInputNode</li>
</ul>
<p>Stores and outputs an integer value via its output port <code>data_out</code>, allowing this nuber to be updated by clients </p>
<ul>
<li>PrimeFactorsNode</li>
</ul>
<p>Expects numeric input values via its input port <code>data_in</code>, computes a list of its prime factors which are output via port <code>data_out</code>.</p>
<ul>
<li>NumberDisplayNode</li>
</ul>
<p>Receives a list of numbers via its input ports <code>integer_data_in</code> amd <code>integerlist_data_in</code>, and communicates those to clients </p>
<h3 id="package-schema">Package Schema</h3>
<p>Each package can define a configuration class - all node instances within a topology that belong to the package.</p>
<p>Each Package, and the Link Types, Node Types it contains, is specified in a JSON formatted document that represents the schema of that Package.</p>
<pre><code>{
    &quot;id&quot;: &quot;numbergraph&quot;,
    &quot;metadata&quot;: {
        &quot;name&quot;: &quot;Number Graph&quot;,
        &quot;version&quot;: &quot;0.0.1&quot;,
        &quot;description&quot;: &quot;a small example package for manipulating numbers&quot;
    },
    &quot;configuration&quot;: {
        &quot;classname&quot;: &quot;numbergraph_configuration.NumbergraphConfiguration&quot;
    },
    &quot;node_types&quot;: {
        &quot;number_input_node&quot;: {
            &quot;metadata&quot;: {
                &quot;name&quot;: &quot;Number Input Node&quot;,
                &quot;description&quot;: &quot;Define an integer value&quot;
            },
            &quot;output_ports&quot;: {
                &quot;data_out&quot;: {
                    &quot;link_type&quot;: &quot;numbergraph:integer&quot;
                }
            },
            &quot;classname&quot;: &quot;nodes.number_input_node.NumberInputNode&quot;
        },
        &quot;prime_factors_node&quot;: {
            &quot;metadata&quot;: {
                &quot;name&quot;: &quot;Prime Factors Node&quot;,
                &quot;description&quot;: &quot;Calculate the prime factors of each input number&quot;
            },
            &quot;input_ports&quot;: {
                &quot;data_in&quot;: {
                    &quot;link_type&quot;: &quot;numbergraph:integer&quot;,
                    &quot;allow_multiple_connections&quot;: false
                }
            },
            &quot;output_ports&quot;: {
                &quot;data_out&quot;: {
                    &quot;link_type&quot;: &quot;numbergraph:integerlist&quot;
                }
            },
            &quot;classname&quot;: &quot;nodes.prime_factors_node.PrimeFactorsNode&quot;
        },
        &quot;number_display_node&quot;: {
            &quot;metadata&quot;: {
                &quot;name&quot;: &quot;Number Display Node&quot;,
                &quot;description&quot;: &quot;Display all input numbers&quot;
            },
            &quot;input_ports&quot;: {
                &quot;integer_data_in&quot;: {
                    &quot;link_type&quot;: &quot;numbergraph:integer&quot;
                },
                &quot;integerlist_data_in&quot;: {
                    &quot;link_type&quot;: &quot;numbergraph:integerlist&quot;
                }
            },
            &quot;output_ports&quot;: {
            },
            &quot;classname&quot;: &quot;nodes.number_display_node.NumberDisplayNode&quot;
        }
    },
    &quot;link_types&quot;: {
        &quot;integer&quot;: {
            &quot;metadata&quot;: {
                &quot;name&quot;: &quot;Integer&quot;,
                &quot;description&quot;: &quot;This type of link carries integer values&quot;
            }
        },
        &quot;integerlist&quot;: {
            &quot;metadata&quot;: {
                &quot;name&quot;: &quot;IntegerList&quot;,
                &quot;description&quot;: &quot;This type of link carries values that are lists of integers&quot;
            }
        }
    }
}
</code></pre>
<p>When refering to a link type, the package id should be used as a prefix, <code>&lt;package-id&gt;:&lt;link-type-id&gt;</code>.  In this example, <code>numbergraph:integer</code> refers to the link type <code>number</code> defined in the <code>numbergraph</code> example package.  This allows packages to refer to link types defined in other packages when defining nodes.</p>
<p>Each Node Type is associated with the following information:</p>
<ul>
<li><code>classname</code> indicates which class implements the node's behaviour</li>
<li><code>input_ports</code> and <code>output_ports</code> specify the names and link types of ports</li>
<li>By default, ports can accept multiple connections unless the <code>allow_multiple_connections</code> is set to false.</li>
<li><code>metadata</code> provides descriptive information </li>
</ul>
<h3 id="the-node-constructor-and-the-run-method">The node constructor, and the run method</h3>
<p>When a node is constructed, the constructor is passed a service API object, providing various useful services.  </p>
<pre><code class="language-py">import math

class PrimeFactorsNode:

    def __init__(self,services):
        self.services = services

    def is_prime(self,n):
        root = int(math.sqrt(n))
        for i in range(2, root + 1):
            if n % i == 0:
                return False
        return True

    def find_prime_factors(self,n):
        factors = self.services.get_configuration().get_prime_factors(n) or []
        if not factors:
            i = 2
            r = n
            while True:
                if r % i == 0:
                    factors.append(i)
                    r //= i
                    if self.is_prime(r):
                        break
                else:
                    i += 1
            if r &gt; 1:
                factors.append(r)
            self.services.get_configuration().set_prime_factors(n, factors)
        return factors

    async def run(self, inputs):
        input_values = inputs.get(&quot;data_in&quot;,[])
        if len(input_values):
            value = input_values[0]
            if not isinstance(value,int):
                raise Exception(f&quot;input value {value} is invalid (not integer)&quot;)
            if value &lt; 2:
                raise Exception(f&quot;input value {value} is invalid (&lt; 2)&quot;)
            prime_factors = self.find_prime_factors(value)
            return { &quot;data_out&quot;:prime_factors }





</code></pre>
<h3 id="persisting-node-properties">Persisting node properties</h3>
<p>Consider a node which supplies an integer values via an output port <code>data_out</code></p>
<pre><code>class NumberInputNode:

    def __init__(self, services):
        self.services = services

    def open_client(self,client_id, client_options, client_service):
        client_service.set_message_handler(lambda *msg: self.__handle_message(client_id, *msg))

    def __handle_message(self,client_id, value):
        if not isinstance(value,int):
            # warn that the client has provided an invalid value
            self.services.set_status_warning(&quot;New value passed by client is not integer&quot;)
        else:
            self.services.set_property(&quot;value&quot;, value)
            self.services.request_run()

    async def run(self, inputs):
        value = self.services.get_property(&quot;value&quot;, 10)
        return { &quot;data_out&quot;: value }
</code></pre>
<p>The integer value is stored in a <code>value</code> property and the services api <code>get_property(name,value)</code> and <code>set_property(name,value)</code> are used to retrieve and update the value.</p>
<p>Property names must be strings and values must be JSON-serialisable objects.</p>
<p>The services API also provides methods to get and set binary data: <code>get_data(name,value)</code> and <code>set_data(name,value)</code> where values of type bytes. In general nodes may use data to persist the results of computation, for example, a machine learning model that the node has trained and then serialised to a sequence of bytes.
In general nodes may use data to persist the results of computation, for example, a machine learning model that the node has trained and then serialised to a sequence of bytes.</p>
<p>When the node is run, its stored value is output on port <code>data_out</code></p>
<h3 id="clients-and-updating-status">Clients and updating status</h3>
<p>Clients are external routines which can communicate with nodes.  Communication happens via message passing, where each message consisting of zero or more values. </p>
<p>To participate, nodes implement <code>open_client</code> and <code>close_client</code> methods.  In the example above, the <code>NumberInputNode</code> expects messages consisting of a single value, used to refresh the number stored by the node.  </p>
<p>Clients allow interaction with the nodes in a topology that is run interactively.</p>
<p>In the <code>NumberInputNode</code> example, once the node updates the value it stores it then calls the service API <code>request_run</code>, indicating that the outputs from the node have changed.  The framework will ensure that the run method will be called soon.  </p>
<p>If the value passed by a client is not an integer, the node will issue a warning via the service api <code>set_status_warning</code>.  The following set of service APIs related to status updates:</p>
<table>
<thead>
<tr>
<th>service API</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>set_status_info(msg)</td>
<td>sets the status as INFORMATIONAL accompanied by message <code>msg</code></td>
</tr>
<tr>
<td>set_status_warning(msg)</td>
<td>sets the status as WARNING accompanied by message <code>msg</code></td>
</tr>
<tr>
<td>set_status_error(msg)</td>
<td>sets the status as ERROR accompanied by message <code>msg</code></td>
</tr>
<tr>
<td>clear_status()</td>
<td>clears the status associated with this node</td>
</tr>
</tbody>
</table>
<h3 id="node-lifecycle-the-load-reset_run-run-and-close-methods">Node lifecycle - the <code>load</code>, <code>reset_run</code>, <code>run</code> and <code>close</code> methods.</h3>
<p>The <code>NumberDisplayNode</code> implements some code to collect input values and report them to any connected clients.</p>
<p>When a topology is loaded, or when any upstream node in the topology is re-run, the node will be constructed and its <code>load</code> method, if implemented, will be called.</p>
<p>As the topology is executed, the node's inputs will be collected and its <code>run</code> method will be called.  But, before this happens, the node's <code>reset_run</code> method will be called, if it is implemented.  A node can implement this method to inform any clients that the node's current results are invalid and the node will soon be re-run.  </p>
<pre><code class="language-py">import json

class NumberDisplayNode:

    def __init__(self, services):
        self.services = services
        self.clients = {}

    def reset_run(self):
        for client_id in self.clients:
            self.clients[client_id].send_message(None)

    async def run(self, inputs):
        input_values = inputs.get(&quot;integer_data_in&quot;,[])+inputs.get(&quot;integerlist_data_in&quot;,[])
        txt = json.dumps(input_values)
        self.services.set_status_info(txt)
        for client_service in self.clients.values():
            client_service.send_message(txt)

    def open_client(self, client_id, client_options, client_service):
        self.clients[client_id] = client_service

    def close_client(self, client_id):
        del self.clients[client_id]

    def close(self):
        pass
</code></pre>
<p>The <code>reset_run</code> method is called as soon as the framework is aware that the node's <code>run</code> method will need to be called. </p>
<p>A node may implement a <code>close</code> method to receive notifications when the node is removed from a topology</p>
<h3 id="defining-the-package-configuration">Defining the package configuration</h3>
<p>The package configuration is defined in a similar way to a node, with a constructor accepting a services object. and an optional load method which is called to load up any additional resources which are needed by the configuration and its nodes.</p>
<p>In this example, the configuration can offer a service to store and retrieve factorisations, that can be accessed by all nodes.</p>
<pre><code class="language-py">import pickle

class NumbergraphConfiguration:

    def __init__(self, services):
        self.services = services
        self.prime_factor_cache = None

    async def load(self):
        cache_data = self.services.get_data(&quot;prime_factors&quot;)
        self.prime_factor_cache = pickle.loads(cache_data) if cache_data else {}
        self.services.set_status_info(f&quot;loaded cache ({len(self.prime_factor_cache)} items)&quot;)

    def get_prime_factors(self, n):
        if n in self.prime_factor_cache:
            return self.prime_factor_cache[n]
        else:
            return None

    def set_prime_factors(self, n, factors):
        self.prime_factor_cache[n] = factors

    def close(self):
        self.services.set_data(&quot;prime_factors&quot;, pickle.dumps(self.prime_factor_cache))
        self.services.set_status_info(f&quot;saved cache ({len(self.prime_factor_cache)} items)&quot;)







</code></pre>
<p>The configuration is then accessed by nodes via the get_configuration service method.  </p>
<p>For more details on the methods that a node or configuration can implement, see</p>
<ul>
<li><a href="node_api/">Node abstract base class API documentation</a></li>
<li><a href="configuration_api/">Configuration abstract base class API documentation</a></li>
</ul>
<p>For more details on the services API passed to node or configuration constructors, see:</p>
<ul>
<li><a href="node_service_api/">Node services API documentation</a></li>
<li><a href="configuration_service_api/">Configuration API documentation</a></li>
</ul>
<h2 id="creating-loading-and-running-topologies-using-the-hyrrokkin-api">Creating, loading and running topologies using the Hyrrokkin API</h2>
<p>Hyrrokkin provides an API for creating, running and loading and saving topologies</p>
<pre><code class="language-py">from hyrrokkin.api.topology import Topology

# provide the resource path to the package containing the schema file
numbergraph_package = &quot;hyrrokkin.example_packages.numbergraph&quot;

t = Topology(execution_folder=tempfile.mkdtemp(),package_list=[numbergraph_package])

t.add_node(&quot;n0&quot;, &quot;numbergraph:number_input_node&quot;, properties={&quot;value&quot;: 99})
t.add_node(&quot;n1&quot;, &quot;numbergraph:prime_factors_node&quot;)
t.add_node(&quot;n2&quot;, &quot;numbergraph:number_display_node&quot;)

t.add_link(&quot;l0&quot;, &quot;n0&quot;, &quot;data_out&quot;, &quot;n1&quot;, &quot;data_in&quot;)
t.add_link(&quot;l1&quot;, &quot;n1&quot;, &quot;data_out&quot;, &quot;n2&quot;, &quot;integerlist_data_in&quot;)
t.run()
</code></pre>
<p>The same topology can be expressed using a YAML file</p>
<pre><code class="language-yaml">metadata:
  name: test topology
configuration:
  numbergraph:
    readonly: false
nodes:
  n0:
    type: numbergraph:number_input_node
    properties:
      value: 99
  n1:
    type: numbergraph:prime_factors_node
  n2:
    type: numbergraph:number_display_node
links:
- n0:data_out =&gt; n1:data_in
- n1:data_out =&gt; n2:integerlist_data_in
</code></pre>
<p>This YAML file can then be imported using the following API calls</p>
<pre><code class="language-py">from hyrrokkin.api.topology import Topology
from hyrrokkin.utils.yaml_importer import import_from_yaml

# provide the resource path to the package containing the schema file
numbergraph_package = &quot;hyrrokkin.example_packages.numbergraph&quot;

t = Topology(execution_folder=tempfile.mkdtemp(),package_list=[numbergraph_package])
with open(&quot;topology.yaml&quot;) as f:
    import_from_yaml(t,f)
t.run()
</code></pre>
<p>Note that in the links section of the YAML file, where nodes have only one input or output port, the port name can be omitted in the links section:</p>
<pre><code class="language-yaml">metadata:
  name: test topology
configuration:
  ...
nodes:
  ...
links:
- n0 =&gt; n1
- n1 =&gt; n2:integerlist_data_in
</code></pre>
<h3 id="saving-and-loading-topologies">Saving and loading topologies</h3>
<p>A topology including its properties and data can be saved to and loaded from a serialised zip format file, using the following API calls.  Saving first:</p>
<pre><code class="language-py">from hyrrokkin.api.topology import Topology

# provide the resource path to the package containing the schema file
numbergraph_package = &quot;hyrrokkin.example_packages.numbergraph&quot;

t = Topology(execution_folder=tempfile.mkdtemp(),package_list=[numbergraph_package])
# create or import the topology
t.run()
with open(&quot;topology.zip&quot;,&quot;wb&quot;) as f:
    t.save(f)
</code></pre>
<p>To load from a saved topology:</p>
<pre><code class="language-py">from hyrrokkin.api.topology import Topology

# provide the resource path to the package containing the schema file
numbergraph_package = &quot;hyrrokkin.example_packages.numbergraph&quot;

t = Topology(execution_folder=tempfile.mkdtemp(),package_list=[numbergraph_package])
with open(&quot;topology.zip&quot;,&quot;rb&quot;) as f:
    t.load(f)
t.run()
</code></pre>
<p>A utility function is also provided to export a topology to YAML format.  Note that the exported YAML file contains node and configuration properties but does not contain node and configuration data.</p>
<pre><code class="language-py">from hyrrokkin.api.topology import Topology
from hyrrokkin.utils.yaml_exporter import export_to_yaml

# provide the resource path to the package containing the schema file
numbergraph_package = &quot;hyrrokkin.example_packages.numbergraph&quot;

t = Topology(execution_folder=tempfile.mkdtemp(),package_list=[numbergraph_package])
with open(&quot;topology.zip&quot;,&quot;rb&quot;) as f:
    t.load(f)
with open(&quot;topology.yaml&quot;,&quot;w&quot;) as f:
    export_to_yaml(t,f)
</code></pre>
<p>For full details on the topology API, see:</p>
<ul>
<li><a href="topology_api/">Topology API documentation</a></li>
</ul>
<h2 id="loading-saving-and-running-topologies-using-topology_runner-cli">loading, saving and running topologies using topology_runner CLI</h2>
<p>The Hyrrokkin package will install a <code>topology_runner</code> CLI command.  Some typical usages include:</p>
<p>Import a topology from zip and run it:</p>
<pre><code class="language-bash">topology_runner --package hyrrokkin.example_packages.numbergraph \      
                --execution-folder /tmp/execution_test \
                --import topology.zip --run
</code></pre>
<p>Import a topology from yaml, run it and save the topology (including data) to a zip file:</p>
<pre><code class="language-bash">topology_runner --package hyrrokkin.example_packages.numbergraph \
                --execution-folder /tmp/execution_test \
                --import topology.yaml \
                --run --export topology.zip
</code></pre>
<p>Convert a topology from zip format to yaml format, but do not run it:</p>
<pre><code class="language-bash">topology_runner --package hyrrokkin.example_packages.numbergraph \
                --execution-folder /tmp/execution_test \
                --import topology.zip \
                --export topology.yaml
</code></pre>
<h2 id="using-the-hyrrokkin-expression-parser">Using the Hyrrokkin expression parser</h2>
<p>Often nodes need to work with string-based expressions, for example:</p>
<p><code>r * sin(theta)</code></p>
<p>Hyrrokkin provides a simple expression based parser which can be set up to parse simple string based expressions into a parse tree.</p>
<pre><code class="language-python">from hyrrokkin.utils.expr_parser import ExpressionParser
import json

ep = ExpressionParser()
ep.add_binary_operator(&quot;*&quot;,1)
print(json.dumps(ep.parse(&quot;10 * sin(pi)&quot;),indent=2))
</code></pre>
<p>This program will print:</p>
<pre><code class="language-json">{
   &quot;operator&quot;: &quot;*&quot;,
   &quot;args&quot;: [
     {
        &quot;literal&quot;: 10
     },
     {
       &quot;function&quot;: &quot;sin&quot;,
       &quot;args&quot;: [
         {
           &quot;name&quot;: &quot;pi&quot;
         }
      ]
    }
  ]
}
</code></pre>
<h3 id="parser-limitations">Parser limitations</h3>
<ul>
<li>unary and binary operators must be explicity registered with the parser </li>
<li>unary operators have higher precedence than binary operators</li>
<li>binary operators must be registered with a precedence</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="configuration_api/" class="btn btn-neutral float-right" title="Configuration api">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
      <span><a href="configuration_api/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="js/jquery-3.6.0.min.js"></script>
    <script>var base_url = ".";</script>
    <script src="js/theme_extra.js"></script>
    <script src="js/theme.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>

<!--
MkDocs version : 1.6.1
Build Date UTC : 2025-03-16 11:53:27.668131+00:00
-->
